# 정렬 정리

다양한 정렬들에 대한 개념 정리 및 코드, 성능에 대해서 조사한 리포지토리입니다.
조사한 정렬은 총 8가지로, 삽입, 선택, 거품, 퀵, 병합, 힙, 계수, 기수가 있습니다.
상대적으로 구현이 쉬운 정렬들은 성능이 떨어지며, 구현이 복잡할 수록 성능이 뛰어납니다.

전체 정렬에 대해서 간단하게 표로 정리하면 아래와 같습니다.

| 이름 | 시간복잡도| 안정성 |  정렬을 위한 추가 공간 필요 |  한줄 정리|
|------|-----------|-------|------------| -----------------------------|
| 삽입 정렬 (Insertion Sort) | O(n^2)| O | X | 정렬된 배열에서 새로운 수 a를 적절한 위치에 삽입하는 정렬 |
| 선택 정렬 (Selection Sort)| O(n^2)| X | X | 정해진 위치 A에 배치한 원소를 선택하는 정렬 | 
| 거품 정렬 (Bubble Sort)| O(n^2)| O | X | 인접한 두 수를 비교, swap 하며 최종 위치에 적절한 원소를 배치하는 정렬 |
| 퀵 정렬 (Quick Sort)| O(n log n)| X | X |  분할 정복 기법을 적용하여 특정한 원소(pivot)을 적절한 위치(주로 가운데)로 배치하는 정렬 |
| 병합 정렬 (Merge Sort)| O(n log n)| O | O | 분할 정복 기법을 적용하여 정렬된 구간들끼리 비교하며 배치하는 정렬 기법 |
| 힙 정렬 (Heap Sort)| O(n log n)| X | O |  힙 자료구조의 성질을 이용한 정렬 기법 |
| 계수 정렬 (Counting Sort)| O(n + k) (k는 max value)| O | O | 각 값들의 개수를 count하여 큰 값부터 배치하는 정렬 기법 |
| 기수 정렬 (Radix Sort)| O(dn) (d는 가장 큰 자리수)| O |  O | 자리수를 기준으로 오름차순 정렬을 반복하는 정렬 기법 |


# 테스트

각 정렬에 대해서 테스트를 진행했다.
테스트 조건은 N이 10^5, 각 원소는 0~N까지의 값을 가졌으며, `Collections.shuffle()` 메서드를 이용하여 순서를 섞어주었다.

## JMH 벤치마킹 (N = 10^5)

|테스트       |      모드|  반복|     성능|     오차|  단위|
|-------------------|--------|---|--------|---------|----------|
|삽입 정렬(Insertion Sort) |    평균 시간 |  10 | 9687.176| ± 386.918 | ms/op|
|거품 정렬(Bubble Sort)   |     평균 시간  | 10|  9466.141| ± 229.986|  ms/op|
|선택 정렬 (Selection Sort) |    평균 시간  | 10 | 6139.201 | ± 137.969|  ms/op|
|힙 정렬(Heap Sort) |     평균 시간  | 10 |   17.130| ±   0.651 | ms/op|
|기수 정렬 (Radix Sort) |    평균 시간  | 10 |    6.321 |±   0.377 | ms/op|
|병합 정렬 (Merge Sort) |    평균 시간  | 10 |    4.321 |±   0.018 | ms/op|
|계수 정렬(Counting Sort)|  평균 시간|   10|     0.777| ±   0.011 | ms/op|


## JUnit5 테스트 결과 (N = 10^5)

![image](https://github.com/kgh2120/sort-perf/assets/76154390/fa00b182-5467-4581-a098-1a113990018c)

